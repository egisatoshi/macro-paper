\documentclass[acmlarge]{acmart}

% page limit: 14 pages

\usepackage{booktabs} % For formal tables

% TOG prefers author-name bib system with square brackets
%\citestyle{acmauthoryear}
%\setcitestyle{square}

\newcommand{\todo}[1]{\textcolor{red}{(TODO: #1)}}

\usepackage{multicol}

\usepackage{xcolor}
\definecolor{P@Blue}{named}{blue}
\definecolor{P@ColorOnBlue}{gray}{.95}
\definecolor{P@GrayFG}{named}{darkgray}
\definecolor{P@GrayBG}{gray}{.90}
\definecolor{P@GrayComment}{gray}{.40}

%\newcommand*\P@listingnumbersfont{%
%  \sffamily\small\color{P@GrayFG!40}%
%  \ifthenelse{\boolean{xetex}\or\boolean{luatex}}%
%    {\firaoldstylemono}
%    {\tbfigures}}%

\RequirePackage{listings}
\lstset{%
  basicstyle=\small\ttfamily,%
  columns=fullflexible,
  extendedchars=true,
  upquote=true,
  captionpos=t,
  backgroundcolor=\color{P@GrayBG},%
  breaklines=true,
  postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{P@Blue}\hookrightarrow\space}},
  numbers=left,
%  numberstyle=\P@listingnumbersfont,
  numbersep=.5em,
  frame=single,
  framerule=0pt}
\lstdefinelanguage{egison}{%
  sensitive = true,
  alsoletter={-},
  keywords = [1]{match-all, match-all-dfs, match-first, define, lambda, and, or, not, later, matcher, something, define-macro, let},
  comment=[l]{;},
}%
\lstset{%
  language={egison},%
  keywordstyle=[1]\textbf,
  keywordstyle=[2]\color{blue},
  stringstyle=\color{RosyBrown},%
  commentstyle={\color{P@GrayComment}},%
}
\lstdefinelanguage{haskell}{%
  sensitive = true,
  comment=[l]{--},
}%
\lstset{%
  language={haskell},%
  keywordstyle=[1]\textbf,
  stringstyle=\color{brown},%
  commentstyle={\color{P@GrayComment}},%
}

\usepackage{bussproofs}
\usepackage{multicol}
\usepackage[mathletters]{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{here}
%\usepackage{url}
%\makeatletter
%\g@addto@macro{\UrlBreaks}{\UrlOrds}
%\makeatother
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\usepackage{syntax}
\usepackage{amssymb}
\usepackage{amsmath}
%\PassOptionsToPackage{dvipsnames}{xcolor}
\usepackage{xcolor}
\usepackage{tcolorbox}
%\usepackage{ascmath}
%\usepackage{ulem}

\EnableBpAbbreviations

\newcommand*{\ppm}[3]{#1 \approx^{#2} #3 \Downarrow}
\newcommand*{\pdm}[2]{#1 \approx #2 \Downarrow}
\newcommand*{\mfun}[4]{#1 \sim^{#2}_{#3} #4 \Downarrow}
\newcommand*{\matom}[3]{#1 \sim_{#2} #3}
\newcommand*{\ev}[2]{#1, #2 \Downarrow}
\newcommand*{\set}[1]{\{#1\}}
\newcommand*{\cons}{:}
\newcommand*{\none}{\mathord{\texttt{none}}}
\newcommand*{\some}{\mathop{\texttt{some}}}
\newcommand*{\opt}{\mathop{\texttt{opt}}}

\newcommand*{\backgray}[1]{\colorbox[gray]{0.9}{\color[gray]{0.0}{#1}}}

\let\emptyset\varnothing

\newcommand{\cL}{{\cal L}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\title{Scheme Macros for Non-linear Pattern Matching with Backtracking for Non-free Data Types}

\author{Satoshi Egi}
\affiliation{%
  \institution{Rakuten Institute of Technology, Rakuten Inc.}
}
\affiliation{%
  \institution{University of Tokyo}
  \country{Japan}
}

\begin{abstract}
  % Context:
  Pattern matching is an important feature of programming languages for data abstraction.
  Many pattern matching extensions have been proposed and implemented for extending the range of data types to which pattern matching is applicable.
  Among them, a pattern-matching system proposed by Egi and Nishiwaki features practical pattern matching for non-free data types with the following three features: (i) non-linear pattern matching with backtracking, (ii) extensibility of pattern-matching algorithms, and (iii) polymorphic patterns.
  % Inquiry:
  They implemented their proposal in an interpreter of the Egison programming language.
  % Approach:
  This paper presents a method for compiling this Egison pattern matching by introducing Scheme macros for importing Egison pattern matching into Scheme.
  We achieved that by transforming a matcher to a function that takes a pattern and a target, and returns lists of triples of a pattern, a matcher, and a target.
  % Knowledge
  This paper also demonstrates the expressiveness of this pattern-matching system by showing redefinitions of the basic list processing functions such as \texttt{map}, \texttt{concat}, or \texttt{unique}, and implementation of a SAT solver as a more practical mathematical algorithm.
  
  % Grounding, and Importance:  
\end{abstract}

% 2012 ACM Computing Classification System (CSS) concepts
% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
% end generated code

% Legacy 1998 ACM Computing Classification System categories are also
% supported, but not recommended.
%\category{CR-number}{subcategory}{third-level}[fourth-level]
%\category{D.3.0}{Programming Languages}{General}
%\category{F.3.2}{Logics and Meanings of Programs}{Semantics of Programming Languages}[Program analysis]

\keywords{pattern-matching-oriented, pattern matching, non-free data types, non-linear pattern, backtracking}

\maketitle

\section{Introduction}\label{intro}

Pattern matching is an important feature of programming languages for data abstraction.
Pattern matching allows us to replace many verbose function applications for decomposing data (such as \texttt{car} and \texttt{cdr}) to an intuitive pattern.
The modern functional programming languages such as Haskell and OCaml support pattern matching for algebraic data types.
Many Scheme implementations also have a similar pattern-matching facility~\cite{gauchePM} though Scheme does not contain pattern matching for algebraic data types in its specification, R7RS~\cite{shinn2013revised}.

However, there are data types that are not algebraic data types and for which we cannt use the common pattern-matching facility.
These data types are called \emph{non-free} data types.
Non-free data have no canonical form as data of algebraic data types.
For example, multisets are non-free data types because the multiset $\{a,b,b\}$ has two other equivalent but syntactically different forms $\{b,a,b\}$ and $\{b,b,a\}$.

Many pattern matching extensions have been proposed and implemented for extending the range of data types to which pattern matching is applicable~\cite{Hudak07ahistory,turner2012some}.
Among them, a pattern-matching system proposed by Egi and Nishiwaki~\cite{egi2018aplas} features practical pattern matching for non-free data types with the following three features: (i) non-linear pattern matching with backtracking, (ii) extensibility of pattern-matching algorithms, and (iii) polymorphic patterns.
However, the pattern-matching algorithm proposed by them is not as simple as the earlier pattern-matching extensions that can be compiled into simple conditional branches and they implemented their proposal only in an interpreter of the Egison programming language.
As a result, a method for importing their pattern matching system into the other functional programming languages was not obvious.

This paper presents a method for integrating this pattern-matching facility of Egison to a dynamically typed functional programming language by introducing Scheme macros for importing Egison pattern matching.
These macros have been already open-sourced in~\cite{egisonScheme}.
We can try them on the Gauche Scheme interpreter~\cite{gaucheWeb}.

The remainder of this paper is organized as follows.
Sect.~\ref{history} reviews the history of pattern-matching extensions and implementation of pattern matching in Scheme.
Sect.~\ref{usage} introduces the usage of the proposed Scheme macros for pattern matching.
Sect.~\ref{apps} shows practical examples of pattern matching for non-free data types.
Sect.~\ref{algorithm} explains the pattern matching algorithm of Egison and implementation of this algorithm in Scheme.
Sect.~\ref{method} explains the implementation of the proposed macros.
Sect.~\ref{future} mentions the remained work.
Finally, Sect.~\ref{conclusion} concludes the paper.

\section{Related Work}\label{history}

This section review a history of pattern matching and implementation of pattern matching in Scheme.

\subsection{History of Pattern Matching and Its Extensions}\label{history1}

Pattern matching that looks similar to pattern matching widely used nowadays was proposed by Burstall in 1969~\cite{burstall1969proving}.
Burstall proposed to use the notation ``\texttt{let cons(a, y) = x}'' instead of ``\texttt{let (a, y) = decons(x)}''.
In~\cite{burstall1969proving}, \texttt{concat} is defined in the modern fashion.

After that, user-defined algebraic data types are invented.
HOPE~\cite{burstall1980hope} proposed in 1980 by Burstall, MacQueen, and Sannella is a well-known language that introduced user-defined algebraic data types and pattern matching for them.

In 1980s, more expressive pattern matching for wider range of data types started to be pursued.
Miranda's laws~\cite{thompson1986laws,thompson1990lawful} and Wadler's views~\cite{wadler1987views} are earlier such research.
They discarded the assumption that one-to-one correspondence should exist between patterns and data constructors.
They enable pattern matching for data types whose data have multiple representation forms.
For example, Wadler's paper on views~\cite{wadler1987views} present pattern matching for complex numbers that have two different representation forms: Cartesian and polar.
However, their expressiveness is not enough for representing patterns for non-free data types.
They neither support non-linear patterns and pattern matching with multiple results.

These works lead to more expressive extensions of pattern matching.
Erwig's active patterns~\cite{erwig1996active} proposed in 1996 and Tullsen's first class patterns~\cite{tullsen2000first} proposed in 2000 are such extensions.
Both extensions allow users to customize the pattern-matching algorithm for each pattern constructor.
Active patterns supports non-linear patterns though they does not support pattern matching with multiple results.
First class patterns supports pattern matching with backtracking though they does not support pattern matching with multiple results.

Egison~\cite{egisonWeb} is a programming language with a pattern matching system that is extensible and supports both of non-linear patterns and multiple results~\cite{egi2018aplas}.
The expressions below match a collection that consists of $n$ zeros as a multiset of integers with patterns that match a collection with sequential pairs and triples.
The \texttt{match-all} expression used in the program below returns a collection evaluating the body expression for all the pattern=matching results.
The target collection contains neither sequential pairs nor triples.
As a result, both expression return an empty collection.
Egison uses backtracking for traversing a search tree.
Therefore, the time for returning the result is same for both expressions.

\begin{lstlisting}[language=egison]
(match-all (take n (repeat 0)) (multiset integer) [<cons $x <cons ,(+ x 1) _>> x])
; returns [] in O(n^2) time
(match-all (take n (repeat 0)) (multiset integer) [<cons $x <cons ,(+ x 1) <cons ,(+ x 2) _>>> x])
; returns [] in O(n^2) time
\end{lstlisting}

\noindent The program below defines a pattern-matching algorithm for a multiset.
The \texttt{matcher} expression used in the following program is a built-in syntax of Egison for defining pattern-matching algorithms for each data type.

\begin{lstlisting}[language=egison]
(define $multiset
  (lambda [$a]
    (matcher
      {[<nil> []
        {[{} {[]}]
         [_ {}]}]
       [<cons $ $> [a (multiset a)]
        {[$tgt (match-all tgt (list a)
                 [<join $hs <cons $x $ts>> [x {@hs @ts}]])]}]
       [,$val []
        {[$tgt (match [val tgt] [(list a) (multiset a)]
                 {[[<nil> <nil>] {[]}]
                  [[<cons $x $xs> <cons ,x ,xs>] {[]}]
                  [[_ _] {}]})]}]
       [$ [something]
        {[$tgt {tgt}]}]})))
\end{lstlisting}

\noindent This paper imports the pattern-matching facility of Egison into Scheme.

\medskip

Pattern matching was also invented in a context of computer algebra.
Pattern matching for symbolical mathematical expression was implemented in the symbol manipulation system proposed by McBride~\cite{mcbride1969symbol}, which was developed on top of Lisp.
This pattern-matching system supports non-linear patterns.
Their paper demonstrates some examples that process symbolic mathematical expressions to show the expressive power of non-linear patterns.
However, this approach does not support pattern matching with multiple results, and users cannot extend its pattern-matching facility.

Queinnec~\cite{queinnec1990compilation} also pursued more expressive pattern matching.
Though this proposal is specialized to lists and not extensible, the proposed language supports the \texttt{cons} and the \texttt{join} patterns, \texttt{match-all}, not-patterns, and recursive patterns.
His proposal achieves almost perfect expressiveness for patterns against lists.

We can regard Egison as an extension of them that adds the customizability of pattern-matching algorithms.

\subsection{Implementation History of Pattern Matching in Scheme}\label{history2}

%As mentioned in Sect~\ref{history1}, expressive pattern matching is proposed and implemented also on Lisp.

Currently, SRFI for pattern matching for algebraic data types does not exist.
However, pattern matching for algebraic data types designed by Wright~\cite{wright1993pattern} is implemented in most of the well-known Scheme implementations such as Gauche~\cite{gauchePM}, Guile~\cite{guilePM}, and Chicken~\cite{chickenPM}.

Among them, Racket~\cite{racketWeb} provides more expressive pattern matching than other Scheme implementations.
The \texttt{match} expander~\cite{tobin2011extensible} of Racket allows users arbitrary transformation of data when pattern matching.
For example, we can describe view patterns~\cite{wadler1987views} using the \texttt{match} expander.

This paper implement more expressive pattern matching that supports non-linear pattern matching with backtracking just by introducing Scheme macros.
This work can be easily ported to other relatives of Scheme.
For example, Yuito Murase has exported the proposed Scheme macros to Common Lisp~\cite{egisonLisp}.

\section{Basic Usage of Proposed Macros}\label{usage}

This section explains the usage of the Scheme library for Egison pattern matching.
%After showing the syntax and list of pattern constructs provided by this library, 

\subsection{Syntax}\label{suyntax}

Here, I show the formal grammar of pattern-matching expressions of the proposed Scheme macros.

\begin{grammar}
<pm-expr> ::= `(match-all' <expr> <expr> <match-clause>         \hfill (match-all)
  \alt `(match-first' <expr> <expr> <match-clause>*      \hfill (match)

<match-clause> ::= `['<pat> <expr>`]' \hfill (match clause)

<pattern> ::= `\_'                    \hfill (wildcard)
  \alt <ident>                        \hfill (pattern variable)
  \alt `\'(' <pattern>* `)'      \hfill (tuple pattern)
  \alt `(' <ident> <pattern>* `)'     \hfill (inductive pattern)
  \alt `,'<expr>                      \hfill (value pattern)
  \alt `(or' <pattern>* `)'      \hfill (or-pattern)
  \alt `(and' <pattern>* `)'     \hfill (and-pattern)
  \alt `(not' <pattern> `)'      \hfill (not-pattern)
  \alt `(later' <pattern> `)'    \hfill (later pattern)
\end{grammar}

The \texttt{match-all} expression has the completely same meaning with that of Egison.
The \texttt{match-first} has similar to the traditional \texttt{match} expression; it evaluates the body of the first match clause whose pattern matches with the target.
The \texttt{match-first} expression can take multiple match clauses.
The only difference between \texttt{match-first} and the traditional \texttt{match} expression is \texttt{match-first} takes a matcher.

This pattern-matching library provides several pattern constructs.
The following subsections explain each of them.

\subsection{Wildcard and Pattern Variables}

Symbols that appear in a pattern are handled as pattern variables.
The value assigned to a pattern variable can be referred to in its right side of the pattern.
``\verb|_|'' represents a wildcard.
A wildcard is pattern-matched with a target in the same method with a pattern variable though no assignment is created for a wildcard.

\subsection{Tuple Patterns}

Tuple patterns are represented by prepending ``\texttt{'}'' to a list of patterns.
Each element of a tuple pattern is pattern-matched with the corresponding element of a target list using the corresponding element of a matcher list as a matcher.

\begin{lstlisting}[language=egison]
(match-all '(1 2) '(Integer Integer) ['(x y) `(,x ,y)]) ; ((1 2))
(match-all '(1 2 3) '(Integer Integer Integer) ['(x y z) `(,x ,y ,z)]) ; ((1 2 3))
\end{lstlisting}

\subsection{Inductive Patterns}

When the pattern is a list, the first element is always handled as a pattern constructor.
For example, \texttt{join} and \texttt{cons} that appear in ``\verb|(join _ (cons x _))|'' are pattern constructors.
The pattern-matching algorithm for handling them is defined and retained in matchers.
For example, in the \texttt{List} matcher, \texttt{join} is defined as a pattern constructor that divides a collection into a head and tail part, and \texttt{cons} is defined as a pattern constructor that divides a collection into the head element and rest.
As a result, the following pattern matches each element of the target list.

\begin{lstlisting}[language=egison]
(match-all '(1 2 3) (List Integer) [(join _ (cons x _)) x]) ; (1 2 3)
\end{lstlisting}

\subsection{Value Patterns}

Value patterns are represented by prepending ``\texttt{,}'' to an expression that is evaluated to a value.
Value patterns are used for expressing non-linear patterns.
The pattern-matching algorithms for value patterns are also defined in matchers.
The program below pattern-matches a list \texttt{(1 2 3 2 1)} as a multiset.
The pattern in the program below matches if the target collection contains pairs of elements in sequence.

\begin{lstlisting}[language=egison]
(match-all '(1 2 5 9 4) (Multiset Integer) [(cons x (cons ,(+ x 1) _)) x]) ; (1 4)
\end{lstlisting}

\subsection{Logical Patterns}

Logical pattern constructs, or-patterns, and-patterns, and not-patterns are useful also in Egison.
Its usage is similar to that in the existing languages.
An or-pattern matches if one of the argument patterns matches the target.
An and-pattern matches if all the argument patterns match the target.
A not-pattern matches if the argument pattern does not match the target.

\begin{lstlisting}[language=egison]
(match-all '(1 2 3) (List Integer) [(cons (or ,1 ,10) _) "OK"]) ; ("OK")
(match-all '(1 2 3) (List Integer) [(cons (and ,1 x) _) x]) ; (1)
(match-all '(1 2 3) (List Integer) [(cons x (not (cons ,x _))) x]) ; (1)
\end{lstlisting}

\subsection{Later Patterns}

A later pattern is used to change the order of the pattern-matching process.
Basically, the pattern-matching system of Egison processes patterns from left to right in order.
However, we sometimes want change this order, for example, to refer to the value bound to the right side of pattern variables.
A later pattern can be used for such purpose.
The pattern inside a later pattern is pattern-matched after pattern matching for the other parts of the pattern succeeded.

\begin{lstlisting}[language=egison]
(match-all '(1 1 2 3) (List Integer) [(cons (later ,x) (cons x _)) x]) ; (1)
\end{lstlisting}


\section{Applications of Pattern Matching for Non-free Data Types}\label{apps}

Before introducing implementation of pattern matching, this section demonstrate the pattern matching facility implemented in this paper to show its usefulness.
We can execute programs shown in this section by loading a program in \cite{egisonScheme} on Gauche~\cite{gaucheWeb}.

\subsection{Redefinitions of Basic List Processing Functions}

Pattern matching for non-free data types enables more intuitive definitions of even the basic list processing functions such as \texttt{map}, \texttt{concat}, and \texttt{unique} by confining recursion inside a pattern.

The \texttt{map} function is defined using pattern matching as follows.
The \texttt{(join _ (cons x _))} pattern matches each element of a target list.
We call this pattern \emph{join-cons pattern} because it often appears in list programming.
Combining a join-cons pattern with \texttt{match-all}, we can simply implement the \texttt{map} function.

\begin{lstlisting}[language=egison]
(define pm-map
  (lambda (f xs)
    (match-all xs (List Something)
      ((join _ (cons x _)) (f x)))))

(pm-map (lambda (x) (+ x 10)) `(1 2 3 4))
; (11 12 13 14)
\end{lstlisting}

\noindent By doubling nesting the above join-cons pattern, we can define the \texttt{concat} function.
Note that, we can create a matcher for such as a list of lists and a multiset of multisets by composing matchers.

\begin{lstlisting}[language=egison]
(define pm-concat
  (lambda (xss)
    (match-all xss (List (List Something))
      ((join _ (cons (join _ (cons x _)) _)) x))))

(pm-concat `((1 2) (3) (4 5)))
; (1 2 3 4 5)
\end{lstlisting}

\noindent By combining a not-pattern, we can define a \texttt{unique} function.
A not-pattern is used to describe that there is no more \texttt{x} after an occurrence of \texttt{x}.
Therefore, this pattern extracts only the last appearance of each element.

\begin{lstlisting}[language=egison]
(define pm-unique-simple
  (lambda (xs)
    (match-all xs (List Eq)
      ((join _ (cons x (not (join _ (cons ,x _))))) x))))

(pm-unique-simple `(1 2 3 2 4))
; (1 3 2 4)
\end{lstlisting}

\noindent We can define \texttt{unique} whose results consist of the first appearance of each element by using a later pattern.

{\footnotesize
\begin{lstlisting}[language=egison]
(define pm-unique
  (lambda (xs)
    (match-all xs (List Eq)
      ((join (later (not (join _ (cons ,x _)))) (cons x _)) x))))

(pm-unique `(1 2 3 2 4))
; (1 2 3 4)
\end{lstlisting}
}

\subsection{Implementation of SAT Solver}

The program below describes the Davis-Putnam algorithm.
We can see a full implementation of this SAT solver in \texttt{dp.scm} of~\cite{egisonScheme}.
Pattern matching for multisets dramatically improves the readability of the description of this algorithm.
We can compare this Scheme program with the OCaml implementation of the same algorithm in~\cite{harrison2009handbook}.

\begin{lstlisting}[language=egison]
(define sat
  (lambda [vars cnf]
    (match-first `[,vars ,cnf] `[,(Multiset Integer) ,(Multiset (Multiset Integer))]
      ['[_ ()] #t]
      ['[_ (cons () _)] #f]
      ['[_ (cons (cons l ()) _)]
       (sat (delete (abs l) vars) (assign-true l cnf))]
      ['[(cons v vs) (not (cons (cons ,(neg v) _) _))]
       (sat vs (assign-true v cnf))]
      ['[(cons v vs) (not (cons (cons ,v _) _))]
       (sat vs (assign-true (neg v) cnf))]
      ['[(cons v vs) _]
       (sat vs (append (resolve-on v cnf)
               (delete-clauses-with v (delete-clauses-with (neg v) cnf))))])))
\end{lstlisting}


\subsection{Prime Numbers}

\texttt{match-all} provided by \verb|stream-egison.scm| supports pattern matching with infinitely many results.
A library for streams described in SRFI 41~\cite{bewig2007scheme} is used for handling lazy lists.
The following \texttt{match-all} expressions extract an infinite list of twin primes and prime triplets from a stream of prime numbers.

\begin{lstlisting}[language=egison]
(load "./stream-egison.scm")

(define stream-primes (stream-filter bpsw-prime? (stream-iota -1)))

(stream->list
 (stream-take
  (match-all stream-primes (List Integer)
             [(join _ (cons p (cons ,(+ p 2) _)))
              `(,p ,(+ p 2))])
  10))
; ((3 5) (5 7) (11 13) (17 19) (29 31) (41 43) (59 61) (71 73) (101 103) (107 109))

(stream->list
 (stream-take
  (match-all stream-primes (List Integer)
             [(join _ (cons p (cons (and (or ,(+ p 2) ,(+ p 4)) m) (cons ,(+ p 6) _))))
              `(,p ,m ,(+ p 6))])
  8))
; ((5 7 11) (7 11 13) (11 13 17) (13 17 19) (17 19 23) (37 41 43) (41 43 47) (67 71 73))
\end{lstlisting}


\section{Algorithm of Egison Pattern Matching}\label{algorithm}

This section explains and implements the pattern-matching algorithm of Egison, which is described in Sect. 5 and Sect. 7 of~\cite{egi2018aplas}.
After the explanation of the pattern-matching algorithm, I introduce a simplified implementation of this algorithm in Scheme.
This implementation is called by the macros whose implementation are introduced in Sect.~\ref{method}.

In Egison, pattern matching is implemented as reductions of stacks of \emph{matching atoms}.
A matching atom is a triple of a pattern, target, and matcher.
In each step of a pattern-matching process, the top matching atom is popped out.
From this matching atom, a list of lists of next matching atoms is calculated.
Each list of the next matching atoms is pushed to the stack of matching atoms.
As a result, a single stack of matching atom is reduced to multiple stacks of matching atoms in a reduction step.
Pattern matching is recursively executed for each stack of matching atoms.
When a stack becomes empty, it means pattern matching for this stack succeeded.
Sect. 5.1 of~\cite{egi2018aplas} shows a sample of this reduction.

\medskip

The \texttt{processMState} function below implements this process.
\texttt{processMState} takes a \emph{matching state} as its argument.
A matching atom consists of a stack of matching atoms and an intermediate result of pattern matching.

The match clause in the 4th and 5th lines describes the case where the matcher of the top matching atom is \texttt{Something}.
In this case, the value \texttt{t} is added to the intermediate pattern-matching result.
\texttt{Something} is the only built-in matcher of the Egison pattern-matching system.
\texttt{something} can handle only wildcards or pattern variables, and is a only matcher that can bind a value to a pattern variable.
The reason why an intermediate result is a list of values and not a list of pairs of a symbol and a value is explained in Sect.~\ref{method-map}.

The match clause in the 6th-8th lines describes the general case.
The list of lists of next matching atoms are calculated in the 7th line.
In this Scheme implementation, a matcher is a function that takes a pattern and a target, and returns a list of lists of the next matching atoms.

In the program below, the matching clauses for and-patterns, or-patterns, not-patterns, and later patterns introduced in Sect.~\ref{usage} are omitted.
We can implement these pattern constructs by adding match clauses for them here.
We can see the full implementation of \texttt{processMState} in \texttt{egison.scm} of~\cite{egisonScheme}.

\begin{lstlisting}[language=egison]
(define processMState
  (lambda (mState)
    (match mState
      ...
      (('MState {[pvar 'Something t] . mStack} ret)
       `((MState ,mStack ,(append ret `(,t)))))
      (('MState {[p M t] . mStack} ret)
       (let {[next-matomss (M p t)]}
         (map (lambda (next-matoms) `(MState ,(append next-matoms mStack) ,ret)) next-matomss))))))
\end{lstlisting}

\medskip

The \texttt{processMStates} below implements the whole pattern-matching process while the above \texttt{processMState} implements a step of this pattern-matching process.
\texttt{processMStates} takes a list of matching states as its argument and returns all pattern-matching results.
The first match clause (the 5th line) describes the case where a list of matching states is empty.
In this case, \texttt{processMStates} simply returns an empty list and terminates.
The second match clause (the 6th and 7th line) describes the case where the stack of the first matching state is empty.
In this case, the intermediate pattern-matching result of this matching state is added to the return value of \texttt{processMStates} as a final result of pattern matching.
\texttt{processMStates} is recursively called for the rest matching states.
The third match clause (the 8th and 9th line) describes the general case.
In this case, \texttt{processMState} is called for the first matching state.
\texttt{processMStates} is recursively called for the result of appending the result of this \texttt{processMState} and the rest matching states.

\begin{lstlisting}[language=egison]
(define processMStates
  (lambda (mStates)
    (match mStates
      (() '{})
      ((('MState '{} ret) . rs)
       (cons ret (processMStates rs)))
      ((mState . rs)
       (processMStates (append (processMState mState) rs))))))
\end{lstlisting}

Here, I simplify the algorithm by omitting the function to traverse an infinitely large search tree.
I omit the explanation of the algorithm for enumerating infinite results of pattern matching in this paper.
It is implemented in \texttt{stream-egison.scm} of~\cite{egisonScheme}.


\section{Implementation Method}\label{method}

This section introduces a method for implementing the \texttt{match-all} macro in Scheme.
Three tricks, which are explained in Sect.~\ref{method-matcher}, Sect.~\ref{method-map}, and Sect.~\ref{method-val-pat} respectively, enable this implementation.

\subsection{Compiling Matchers to \texttt{lambda}s}\label{method-matcher}

In the original paper of Egison pattern matching~\cite{egi2018aplas}, a matcher is a special object that retains a pattern-matching algorithm.
In the proposed Scheme macros, for encoding a matcher with lambda to avoid introducing new built-in objects, a matcher is defined as a function that takes a pattern and a target, and returns a list of lists of next matching atoms.
For example, the \texttt{Multiset} matcher is defined as follows.

\begin{lstlisting}[language=egison]
(define Multiset
  (lambda (M)
    (lambda (p t)
      (match p
        (('nil) (if (eq? t '()) '{{}} '{}))
        (('cons px py)
         (map (lambda (xy) `{[,px ,M ,(car xy)] [,py ,(Multiset M) ,(cadr xy)]})
              (match-all t (List M)
                [(join hs (cons x ts)) `(,x ,(append hs ts))])))
        (('val v)
         (match-first `(,t ,v) `(,(List M) ,(Multiset M))
           ('((nil) (nil)) '{{}})
           ('((cons x xs) (cons ,x ,xs)) '{{}})
           ('(_ _) '{})))
        (pvar `{{[,pvar Something ,t]}})))))
\end{lstlisting}

In the above program, we uses ``\texttt{\{\}}'' and ``\texttt{[]}'' separately.
We use braces ``\texttt{\{\}}'' for enclosing a list.
For example, a list of matching atoms is enclosed with braces.
We use brackets ``\texttt{[]}'' for enclosing a tuple.
For example, a matching atom, which is a triple of a pattern, a matcher, and a target, is enclosed with brackets.

As a matcher definition of Egison~\cite{egi2018aplas} that consists of matcher clauses that describe pattern matching for patterns to describe pattern-matching algorithms for each pattern, the above matcher definition describe pattern matching for patterns.
For pattern matching against patterns, \texttt{match} is used.

The first match clause (the 5th line) describes a pattern-matching algorithm for the \texttt{nil} pattern that matches with an empty list.
When the target list is empty, this match clause returns a list that consists of an empty list of matching atoms.
Otherwise, this match clause returns an empty list.
That means pattern matching fails.

The second match clause (the 6th-9th lines) describes a pattern-matching algorithm for the \texttt{cons} pattern.
The pattern of this match clause is  ``\texttt{('cons px py)}''.
The first and second argument of the \texttt{cons} pattern is assigned to \texttt{px} and \texttt{py} respectively.
The body of this match clause is a bit complicated.
The evaluation result of this body expression depends on the target list.
Now, we consider a case where the target list is ``\texttt{(1 2 3)}''.
In this case, this body expression is evaluated to ``\texttt{\{\{[px M 1] [py (Multiset M) (2 3)]\} \{[px M 2] [py (Multiset M) (1 3)]\} \{[px M 3] [py (Multiset M) (1 2)]\}\}}''.
Each list of the next matching atoms is pushed to the current matching state; as a result, three new matching states are generated.
For the first matching state, \texttt{1} and \texttt{(2 3)} are pattern-matched using the ``\texttt{M}'' and ``\texttt{Multiset M}'' matcher with the patterns \texttt{px} and \texttt{py}, respectively, in the succeeding pattern-matching process.

The third match clause (the 10th-14th line) describes a pattern-matching algorithm for a value pattern.
The body of this match clause compares the target and the value inside the value pattern.
The \texttt{match-first} expression that recursively calls the \texttt{Multiset} matcher is used for this comparison.

The fourth match clause (the 15th line) describes a pattern-matching algorithm for a pattern variable and wildcard.
This match clause creates the next matching atom by just changing the matcher from ``\texttt{Multiset M}'' to \texttt{Something}.

\subsection{Compiling \texttt{match-all} to Application of \texttt{map}}\label{method-map}

The \texttt{match-all} expression is transformed into an application of \texttt{map} whose first argument is a function whose argument is a return value of \texttt{extract-pattern-variables}, and second argument is the result of \texttt{gen-match-results}.
The \texttt{extract-pattern-variables} function takes a pattern and returns a list of pattern variables that appear in the pattern.
The order of the pattern variables corresponds with the order they appeared in the pattern.
The \texttt{gen-match-results} function returns a list of gen-match-resultsing results.
The gen-match-resultsing results consist of values that are going to bound to the pattern variables returned by \texttt{extract-pattern-variables}.
The order of the values in the gen-match-resultsing results must correspond with the order of pattern variables returned by \texttt{extract-pattern-variables}.

\begin{lstlisting}[language=egison]
(match-all t M [p e])
;=> `(map (lambda ,(extract-pattern-variables p) ,e) ,(gen-match-results p M t))
\end{lstlisting}

\noindent The above transformation is done by The following macro.

\begin{lstlisting}[language=egison]
(define-macro (match-all t M clause)
  (let* {[p (rewrite-pattern (list 'quasiquote (car clause)))]
         [e (cadr clause)]}
    `(map (lambda (ret) (apply (lambda ,(extract-pattern-variables p) ,e) ret))
          (gen-match-results ,p ,M ,t))))
\end{lstlisting}

\noindent The program below defines \texttt{gen-match-results}.
\texttt{gen-match-results} is a macro that just calls the \texttt{processMStates} function introduced in Sect.~\ref{algorithm}.
An initial matching state ``\verb|(MState {[p M t]} {})|'' is created from ``\texttt{p}'', ``\texttt{M}'', and ``\texttt{t}''.

\begin{lstlisting}[language=egison]
(define-macro (gen-match-results p M t)
  `(processMStates (list (list 'MState (list (list ,p ,M ,t) ) {}))))
\end{lstlisting}

\medskip

Thus, by separating the extraction of pattern variables and the calculation of pattern-matching results, we can compile such a complicated pattern matching process.
However, this separation disable to apply the existing method for compiling pattern matching efficiently.
\todo{FIX}

\subsection{Compiling value patterns to \texttt{lambda}s}\label{method-val-pat}

This section explains a method for compiling value patterns.
A value pattern is transformed into a \texttt{lambda} expression whose arguments are pattern variables that appear in the left-side of the value pattern.
For example, ``\texttt{(cons x (cons y (cons ,x (cons z _))))}'' is transformed into ``\texttt{(cons x (cons y (cons (val ,(lambda (x y) x)) (cons z _))))}''.
The \texttt{rewrite-pattern} function called inside the macro does this transformation.

This transformed value pattern is handled in \texttt{processMState}.
The following program shows a match clause in \texttt{processMState} for handling a value pattern, which is omitted in the explanation of \texttt{processMState} in Sect.~\ref{algorithm}.

\begin{lstlisting}[language=egison]
(define processMState
  (lambda (mState)
    (match mState
      (('MState {[('val f) M t] . mStack} ret)
       (let {[next-matomss (M `(val ,(apply f ret)) t)]}
         (map (lambda (next-matoms) `(MState ,(append next-matoms mStack) ,ret)) next-matomss)))
      ...)))
\end{lstlisting}

\noindent
When the pattern of the top matching atom is a value pattern, it applies intermediate pattern-matching result to the function in the value pattern and passes it to the matcher.
This pattern is handled by the third match clause of the \texttt{Multiset} matcher in Sect.~\ref{method-matcher}, for example.

\section{Future Work}\label{future}

%\subsection{Performance}
%
%Efficient data structures are needed.
%
%table of benchmark results.
%
%Scheme macros
%
%Egison interpreter in Haskell
%
%lazy evaluation

\subsection{Importation of More Expressive Pattern Constructs}

Extending our macros for supporting loop patterns~\cite{egi2018loop} is also future work.

\subsection{Integration with Statically Typed Languages}

Integration of Egison pattern matching with a programming language with a static type system remains as future work.
We have an experimental Template Haskell implementation~\cite{egisonHaskell}.
Currently, this Haskell implementation has a problem that it does not allow users to define new pattern constructors.
The Haskell program below shows the definition of \texttt{Pattern a}, which is a data type for patterns against data whose type is \texttt{a}.
Haskell does not allow to add new data constructors to a data type defined in a different file.
Therefore, users cannot add a new pattern constructor in their program.

\begin{lstlisting}[language=haskell]
data Pattern a where
  Wildcard  :: Pattern a
  PatVar    :: String -> Pattern a
  ValuePat :: Eq a => ([Result] -> a) -> Pattern a
  ValuePat'  :: Eq a => a -> Pattern a
  AndPat :: Pattern a -> Pattern a -> Pattern a
  OrPat :: Pattern a -> Pattern a -> Pattern a
  NotPat :: Pattern a -> Pattern a
  LaterPat :: Pattern a -> Pattern a
  PredicatePat :: (a -> Bool) -> Pattern a
  NilPat :: a ~ [b] => Pattern a
  ConsPat :: a ~ [b] => Pattern b -> Pattern a -> Pattern a
  JoinPat :: a ~ [b] => Pattern a -> Pattern a -> Pattern a
\end{lstlisting}

\section{Conclusion}\label{conclusion}

This paper proposed a method for compiling Egison pattern-matching expressions that can describe very expressive patterns for non-free data types but has a large complicate pattern-matching procedure.
The proposed method made an implementation of the pattern-matching system of Egison very short; the macros and the pattern-matching procedure is implemented in less than 150 lines of Scheme code (\texttt{egison.scm} of~\cite{egisonScheme}).
This is also a good proof of extensibility of Scheme and Lisp.

This pattern matching library will help education of algorithms by making its implementation simpler as the implementation of a SAT solver presented in this paper.
This pattern matching library will also help research of pattern matching by providing a easy method for developing new pattern-matching extensions.
I hope this work leads to the further development and  propagation of advanced pattern matching.

%\begin{acks}
%Yuichi Nishiwaki
%Mayuko Kori
%\end{acks}

% Bibliography
\bibliographystyle{ACM-Reference-Format}
\bibliography{main}

\end{document}
